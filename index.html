<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="description" content="CodeV-All">
  <meta name="keywords" content="Language Language Model, Program synthesis">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>CodeV-All</title>

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-PYVRSFMDRL"></script>
  <script>
    window.dataLayer = window.dataLayer || [];

    function gtag() {
      dataLayer.push(arguments);
    }

    gtag('js', new Date());

    gtag('config', 'G-PYVRSFMDRL');
  </script>

  <!-- highlight code -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <!-- 引入 Verilog 和 Scala 语言支持 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/verilog.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/scala.min.js"></script>
  <script>hljs.highlightAll();</script>


  <link href="https://fonts.googleapis.com/css?family=Google+Sans|Noto+Sans|Castoro" rel="stylesheet">

  <link rel="stylesheet" href="./static/css/bulma.min.css">
  <link rel="stylesheet" href="./static/css/bulma-carousel.min.css">
  <link rel="stylesheet" href="./static/css/bulma-slider.min.css">
  <link rel="stylesheet" href="./static/css/fontawesome.all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jpswalsh/academicons@1/css/academicons.min.css">
  <link rel="stylesheet" href="./static/css/index.css">
  <!-- <link rel="icon" href="./static/images/logo.png"> -->
  <link rel="stylesheet" href="./static/css/card.css">

  <!-- Add custom CSS for hover effect -->
  <style>
    .card {
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    .card:hover {
      transform: scale(1.05);
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
    }
  </style>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
  <script defer src="./static/js/fontawesome.all.min.js"></script>
  <script src="./static/js/bulma-carousel.min.js"></script>
  <script src="./static/js/bulma-slider.min.js"></script>
  <script src="./static/js/index.js"></script>
  <script src="./static/js/card.js"></script>
</head>

<body>


  <section class="hero">
    <div class="hero-body">
      <div class="container is-max-desktop">
        <div class="columns is-centered">
          <div class="column has-text-centered">
            <h1 class="title is-1 publication-title">CodeV: Empowering LLMs for Verilog Generation through Multi-Level Summarization
            </h1>
            <div class="is-size-5 publication-authors">
              <span class="author-block">
                <a>Yang Zhao</a><sup>1,2,5</sup>,</span>
              <span class="author-block">
                <a>Di Huang</a><sup>1</sup>,</span>
              <span class="author-block">
                <a>Chongxiao Li</a><sup>1,2,5</sup>,
              </span>
              <span class="author-block">
                <a>Pengwei Jin</a><sup>1,2,5</sup>,
              </span>
              <span class="author-block">
                <a>Muxin Song</a><sup>3</sup>,
              </span>
              <span class="author-block">
                <a>Yinan Xu</a><sup>1</sup>,
              </span>
              <span class="author-block">
                <a>Ziyuan Nan</a><sup>1,2,5</sup>,
              </span>
              <span class="author-block">
                <a>Mingju Gao</a><sup>1,2,5</sup>,
              </span>
              <span class="author-block">
                <a>Tianyun Ma</a><sup>1,4</sup>,
              </span>
              <span class="author-block">
                <a>Lei Qi</a><sup>1,4</sup>,
              </span>
              <span class="author-block">
                <a>Yansong Pan</a><sup>1,2,5</sup>,
              </span>
              <span class="author-block">
                <a>Zhenxing Zhang</a><sup>1,4</sup>,
              </span>
              <span class="author-block">
                <a>Rui Zhang</a><sup>1</sup>,
              </span>
              <span class="author-block">
                <a>Xishan Zhang</a><sup>1,5</sup>,
              </span>
              <span class="author-block">
                <a>Zidong Du</a><sup>1,6</sup>,
              </span>
              <span class="author-block">
                <a>Qi Guo</a><sup>1</sup>,
              </span>
              <span class="author-block">
                <a>Xing Hu</a><sup>1,6</sup>
              </span>
            </div>

            <div class="is-size-5 publication-authors">
              <span class="author-block"><sup>1</sup>State Key Lab of Processors, Institute of Computing Technology, Chinese Academy of Science</span><br>
              <span class="author-block"><sup>2</sup>University of Chinese Academy of Sciences</span><br>
              <span class="author-block"><sup>3</sup>School of Information Science and Technology, ShanghaiTech University</span><br>
              <span class="author-block"><sup>4</sup>University of Science and Technology of China</span><br>
              <span class="author-block"><sup>5</sup>Cambricon Technologies</span><br>
              <span class="author-block"><sup>6</sup>Shanghai Innovation Center for Processor Technologies</span>
            </div>

            <div class="column has-text-centered">
              <div class="publication-links">
                <!-- PDF Link. -->
                <span class="link-block">
                  <a href="https://arxiv.org/abs/2407.10424" class="external-link button is-normal is-rounded is-dark">
                    <span class="icon">
                      <i class="ai ai-arxiv"></i>
                    </span>
                    <span>arXiv</span>
                  </a>
                </span>
                <!-- Code Link. -->
                <span class="link-block">
                  <a href="https://github.com/iprc-dip/CodeV" class="external-link button is-normal is-rounded is-dark">
                    <span class="icon">
                      <i class="fab fa-github"></i>
                    </span>
                    <span>Code</span>
                  </a>
                </span>
                <!-- Raw data Link-->
                <span class="link-block">
                  <a href="https://huggingface.co/yang-z"
                    class="external-link button is-normal is-rounded is-dark">
                    <span class="icon">
                      <i class="fas fa-cloud-download-alt"></i>
                    </span>
                    <span>Download</span>
                  </a>
                </span>
                <!-- Raw data Link-->
                <span class="link-block">
                  <a href="https://iprc-dip.github.io/Chip-Design-LLM-Zoo/"
                    class="external-link button is-normal is-rounded is-dark">
                    <span class="icon">
                      <i class="fas fa-trophy"></i>
                    </span>
                    <span>Leaderboard</span>
                  </a>
                </span>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </section>

  <section class="section">
    <div class="container is-max-desktop">
      <!-- Abstract. -->
      <div class="columns is-centered has-text-centered">
        <div class="column is-four-fifths">
          <h2 class="title is-3">Abstract</h2>
          <div class="content has-text-justified">
            <p>
              The design flow of processors, particularly in hardware description languages (HDL) like Verilog and Chisel, is complex and costly. While recent advances in large language models (LLMs) have significantly improved coding tasks in software languages such as Python, their application in HDL generation remains limited due to the scarcity of high-quality HDL data. Traditional methods of adapting LLMs for hardware design rely on synthetic HDL datasets, which often suffer from low quality because even advanced LLMs like GPT perform poorly in the HDL domain. Moreover, these methods focus solely on chat tasks and the Verilog language, limiting their application scenarios.
              </p>
              <p>
              In this paper, we observe that: (1) HDL code collected from the real world is of higher quality than code generated by LLMs. (2) LLMs like GPT-3.5 excel in summarizing HDL code rather than generating it. (3) An explicit language tag can help LLMs better adapt to the target language when there is insufficient data. Based on these observations, we propose an efficient LLM fine-tuning pipeline for HDL generation that integrates a multi-level summarization data synthesis process with a novel Chat-FIM-Tag supervised fine-tuning method. The pipeline enhances the generation of HDL code from natural language descriptions and enables the handling of various tasks such as chat and infilling incomplete code.
              Utilizing this pipeline, we introduce CodeV, a series of HDL generation LLMs. Among them, CodeV-All not only possesses a more diverse range of language abilities, i.e., Verilog and Chisel, and a broader scope of tasks, i.e., Chat and fill-in-middle (FIM), but it also achieves performance on VerilogEval that is comparable to or even surpasses that of <em>ModelName-Verilog</em> fine-tuned on Verilog only, making them the first series of open-source LLMs designed for multi-scenario HDL generation.
              </p>
          </div>
        </div>
      </div>
      <!--/ Abstract. -->

      <!-- Overview. -->
      <div class="columns is-centered has-text-centered">
        <div class="column">
          <h2 class="title is-3">Overview</h2>
          <div class="content">
            <p>
              We first gather and refine high-quality Verilog and Chisel code from open-source repositories. These codes are processed by GPT-3.5 to generate multi-level summaries. By pairing high-level descriptions with their respective codes, we create a high-quality dataset used to fine-tune base LLMs, resulting in the CodeV model series.
            </p>
          </div>
          <img src="./static/images/overview_v20250413.png">
        </div>
      </div>
      <!--/ Overview. -->
    </div>
  </section>

  <section class="section">
    <div class="container is-max-desktop">
    <!-- Three-Column Showcase Section with Hover Effect -->
      <div class="columns is-centered">
        <div class="column">
          <div class="content has-text-centered">
            <h2 class="title is-3">CodeV Showcase</h2>
            <p>Explore examples of CodeV-Series's capabilities in generating high-quality HDL code.</p>
          </div>
          <div class="columns is-multiline is-centered" id="showcase-columns">
            <!-- Column 1 -->
            <div class="column is-one-third">
              <div class="card">
                <div class="card-content">
                  <div class="content">
                    <h4 class="title is-5">CodeV-Verilog</h4>
                    <p>CodeV-Verilog generates accurate Verilog modules from natural language descriptions.</p>
                  </div>
                  <hr/>
                  <div class="content" style="margin-bottom: 0.5rem;">
                    <h4 class="title is-5">Format</h4>
                    <p>Problem Description <span class="problem-dot"></span></p>
                    <p>Code <span class="code-dot"></span></p>
                  </div>
                  <hr/>
                  <div class="problem-description">
                    <h5 class="title is-6 has-text-weight-bold">Problem Description</h5>
                    <p>Create a Verilog module for an 8-bit counter that increments on each positive clock edge and resets to zero when a reset signal is active.</p>
                  </div>
                  <div class="code-block">
                    <pre class="card"><code class="language-verilog">
  module counter (
  input clk,
  input rst,
  output reg [7:0] count
  );
  always @(posedge clk or posedge rst) begin
      if (rst)
          count <= 8'b0;
      else
          count <= count + 1;
  end
  endmodule
                    </code></pre>
                  </div>
                </div>
              </div>
            </div>
            <!-- Column 2 -->
            <div class="column is-one-third">
              <div class="card">
                <div class="card-content">
                  <div class="content">
                    <h4 class="title is-5">CodeV-All</h4>
                    <p>CodeV-All supports generating Chisel and Verilog code, and can complete code filling tasks in FIM format.</p>
                  </div>
                  <hr/>
                <div class="content">
                  <h4 class="title is-5">Format</h4>
                  <p>Problem Description <span class="problem-dot"></span></p>
                  <p>Code <span class="code-dot"></span></p>
                  <p>PRE+SUF <span class="pre-suf-dot"></span></p>
                  <p>MID <span class="mid-dot"></span></p>
                </div>
                <hr/>
                  <div class="problem-description">
                    <h5 class="title is-6 has-text-weight-bold">Problem Description</h5>
                    <p>Create a Verilog module for an 8-bit counter that increments on each positive clock edge and resets to zero when a reset signal is active.</p>
                  </div>
                  <div class="code-block">
                    <pre class="card"><code class="language-scala">
  import chisel3._
  
  class Counter extends Module {
  val io = IO(new Bundle {
  val count = Output(UInt(8.W))
  })
  val counter = RegInit(0.U(8.W))
  counter := counter + 1.U
  
  
  io.count := counter
  }
                    </code></pre>
                  </div>
                </div>
              </div>
            </div>
            <!-- Column 3 -->
            <div class="column is-one-third">
              <div class="card">
                <!-- <div class="card-image">
                  <figure class="image is-4by3">
                    <img src="./static/images/fim_example.png" alt="FIM Example">
                  </figure>
                </div> -->
                <div class="card-content">
                  <div class="content">
                    <h4 class="title is-5">CodeV-R1</h4>
                    <p>CodeV-R1 is a reasoning code model that generates more accurate code through an explicit reasoning process.</p>
                  </div>
                <hr/>
                <div class="content">
                  <h4 class="title is-5">Format</h4>
                  <p>Problem Description<span class="problem-dot"></span></p>
                  <p>Reasoning Process<span class="reason-dot"></span></p>
                  <p>Code<span class="code-dot"></span></p>
                </div>
                <hr/>
                <div class="content">
                  <h4 class="title is-5">VerilogEval V2</h4>
                  <p>Case 1:</p>
                </div>
                <div class="problem-description">
                  <h5 class="title is-6 has-text-weight-bold">Problem Description</h5>
                  <p style="white-space: pre-wrap;">I would like you to implement a module named TopModule with the following
interface. All input and output ports are one bit unless otherwise
specified.

- input clk
- input reset
- input in (8 bits)
- output out_bytes (24 bits)
- output done

The module should implement a finite state machine that will search for
message boundaries when given an input byte stream. The algorithm we'll
use is to discard bytes until we see one with in[3]=1. We then assume
that this is byte 1 of a message, and signal the receipt of a message
once all 3 bytes have been received (done). The FSM should signal done in
the cycle immediately after the third byte of each message was
successfully received.

Implement the datapath module that will output the 24-bit (3 byte)
message whenever a packet is received (out_bytes[23:16] is the first
byte, out_bytes[15:8] is the second byte, etc.). The reset signal is
active high synchronous. out_bytes needs to be valid whenever the done
signal is asserted. You may output anything at other times (i.e.,
don't-care). Assume all sequential logic is triggered on the positive
edge of the clock.

Here is an example waveform:

time clk rst in done out_bytes
0ns 0 1 0 x x
5ns 1 1 0 0 x
10ns 0 1 0 0 x
15ns 1 0 2c 0 x
20ns 0 0 2c 0 x
25ns 1 0 81 0 x
30ns 0 0 81 0 x
35ns 1 0 9 0 x
40ns 0 0 9 0 x
45ns 1 0 6b 1 2c8109
50ns 0 0 6b 1 2c8109
55ns 1 0 d 0 x
60ns 0 0 d 0 x
65ns 1 0 8d 0 x
70ns 0 0 8d 0 x
75ns 1 0 6d 1 6b0d8d
80ns 0 0 6d 1 6b0d8d
85ns 1 0 12 0 x
90ns 0 0 12 0 x
95ns 1 0 1 0 x
100ns 0 0 1 0 x
105ns 1 0 d 1 6d1201
110ns 0 0 d 1 6d1201
115ns 1 0 76 0 x
120ns 0 0 76 0 x
125ns 1 0 3d 0 x
130ns 0 0 3d 0 x
135ns 1 0 ed 1 d763d
140ns 0 0 ed 1 d763d
145ns 1 0 8c 0 x
150ns 0 0 8c 0 x
155ns 1 0 f9 0 x
160ns 0 0 f9 0 x
165ns 1 0 ce 1 ed8cf9
170ns 0 0 ce 1 ed8cf9
175ns 1 0 c5 0 x
180ns 0 0 c5 0 x
185ns 1 0 aa 0 x
190ns 0 0 aa 0 x</p>
                </div>
                <div class="reasoning-process">
                  <h5 class="title is-6 has-text-weight-bold">Reasoning Process</h5>
                  <ol>
                    <li>
                      <strong>Initial Understanding &amp; Identifying Core Conflict:</strong>
                      <ul>
                        <li>Understood the basic goal: find byte with <code>in[3]==1</code>, capture it plus the next two bytes, output out_bytes and done.</li>
                        <li>
                          <em>Effective Reflection:</em> Immediately noticed a conflict between the problem description (done asserted after the 3rd byte) and the waveform example (done asserted concurrently with the 3rd byte's arrival).
                          "...<em>Wait, the done is asserted in the cycle after the third byte is received? Hmm, the waveform example shows that when the third byte arrives ... done is 1...</em>"
                          "...<em>Wait the description says: ... signal done on the next cycle. Wait the done is in the cycle after third byte.</em>"
                          "...<em>Wait the example: ... At time 45ns, the input is 6b, then done is 1...</em>"
                        </li>
                      </ul>
                    </li>
                    <li>
                      <strong>Resolving the done Timing Conflict:</strong>
                      <ul>
                        <li>Analyzed both the text description and the waveform example multiple times. "...<em>Hmm, this is conflicting.</em>"</li>
                        <li>
                          <em>Key Decision:</em> Explicitly decided to prioritize the waveform example's behavior for the implementation.
                          "<strong>But the example is definitely like: Third byte's time is when done is high. So code must be in same cycle.</strong>"
                          "...<strong>Wait yes. So the done_reg is 1 during the cycle when the third byte is stored (the same as the example). This aligns with the example.</strong>"
                        </li>
                      </ul>
                    </li>
                    <li>
                      <strong>Choosing FSM Implementation Strategy:</strong>
                      <ul>
                        <li>Considered different FSM structures (named states like IDLE, GOT_1, GOT_2, DONE vs. using a counter). "...<em>But perhaps using a counter.</em>" ... "<em>Alternatively, let's use a state machine...</em>"</li>
                        <li>
                          <em>Key Decision:</em> Converged on using a simple 2-bit counter (<code>count</code>) to track the byte collection process (0: idle, 1: got first, 2: got second), finding it more direct.
                          "<strong>So using a count (from 0 to 2?) as the number of collected bytes beyond the first.</strong>"
                          "...<strong>The code can use a 2-bit count...</strong>" (leading to the final approach).
                        </li>
                      </ul>
                    </li>
                    <li>
                      <strong>Designing the Core Logic (Handling the 3rd Byte):</strong>
                      <ul>
                        <li>
                          <em>Key Insight:</em> Realized that when the <code>count</code> is 2, the system has already stored <code>byte1</code> and <code>byte2</code>, and the current <code>in</code> signal holds the required third byte.
                        </li>
                        <li>
                          <em>Key Logic:</em> Determined the actions for the <code>count == 2</code> state:
                          <ul>
                            <li>Assign the output directly: <code>out_bytes &lt;= {byte1, byte2, in};</code> (avoids needing a <code>byte3</code> register).</li>
                            <li>Assert the <code>done</code> signal: <code>done &lt;= 1;</code>.</li>
                            <li>Reset the process: <code>count &lt;= 0;</code>.</li>
                          </ul>
                        </li>
                        <li>
                          "...<code>else if (count ==2) begin ... out_bytes &lt;= {byte1, byte2, in}; done &lt;=1; count &lt;=0; end</code>"
                          "...<strong>Thus in the code: The done is set in the same cycle as the third byte is received.</strong>"
                        </li>
                      </ul>
                    </li>
                  </ol>
                </div>
                <div class="code-block">
                  <pre class="card"><code class="language-verilog">
module TopModule (
    input clk,
    input reset,
    input [7:0] in,
    output reg [23:0] out_bytes,
    output reg done
);

    reg [1:0] count; // 用计数器代替状态名，00: IDLE, 01: Got Byte 1, 10: Got Byte 2
    reg [7:0] byte1, byte2; // 只需要存储前两个字节

    always @(posedge clk) begin
        if (reset) begin
            count <= 2'b00;
            done <= 1'b0;
            byte1 <= 8'h00;
            byte2 <= 8'h00;
            out_bytes <= 24'h0;
        end else begin
            done <= 1'b0; // 每个周期默认拉低 done

            case (count)
                2'b00: begin // IDLE 状态
                    if (in[3]) begin
                        byte1 <= in;     // 锁存第一个字节
                        count <= 2'b01;  // 下个周期进入状态 1
                    end
                end
                2'b01: begin // 已收到第1个字节，等待第2个
                    byte2 <= in;     // 锁存第二个字节
                    count <= 2'b10;  // 下个周期进入状态 2
                end
                2'b10: begin // 已收到第2个字节，当前 'in' 是第3个字节
                    // **** 正确的关键 ****
                    out_bytes <= {byte1, byte2, in}; // 在 *当前* 周期，使用已存储的 byte1, byte2 和 *当前* 输入的 in 来准备输出
                    done <= 1'b1;                   // 在 *当前* 周期，准备将 done 置 1
                    count <= 2'b00;                 // 下个周期返回 IDLE 状态
                end
                default: count <= 2'b00;
            endcase
        end
    end

endmodule
                  </code></pre>
                </div>
                <div class="content">
                  <h4 class="title is-5"></h4>
                  <p>Case 2:</p>
                </div>
                <div class="problem-description">
                  <h5 class="title is-6 has-text-weight-bold">Problem Description</h5>
                  <p style="white-space: pre-wrap;">I would like you to implement a module named TopModule with the following
interface. All input and output ports are one bit unless otherwise
specified.
input x (4 bits)
output f
The module should implement the function f shown in the Karnaugh map
below. d is don't-care, which means you may choose to output whatever
value is convenient.
x[1]x[2]
x[3]x[4] 00 01 11 10
00 | d | 0 | d | d |
01 | 0 | d | 1 | 0 |
11 | 1 | 1 | d | d |
10 | 1 | 1 | 0 | d |
                  </p>
                </div>
                <div class="reasoning-process">
                  <h5 class="title is-6 has-text-weight-bold">Reasoning Process</h5>
                  <ol>
                    <li>
                      <strong>K-map Interpretation &amp; Variable Identification:</strong>
                      <ul>
                        <li>Initial confusion about K-map layout (rows vs. columns). "...<em>Wait, looking at the columns and rows...</em>"</li>
                        <li>
                          <strong>Key Step:</strong> Meticulously transcribed the K-map values, correctly establishing the mapping: Rows correspond to x3x4 values (00, 01, 11, 10) and Columns correspond to x1x2 values (00, 01, 11, 10). "<strong>So the entire K-map would look like this:...</strong>"
                        </li>
                        <li>
                          <strong>Key Step &amp; Reflection:</strong> Identified the four input variables involved as x1, x2, x3, x4 based on the K-map labels. "<em>Wait, the variables are four: x3, x4, x1, x2...</em>"
                        </li>
                      </ul>
                    </li>
                    <li>
                      <strong>Variable Naming and Verilog Input Declaration:</strong>
                      <ul>
                        <li>Noticed the potential ambiguity between the input declaration x (4 bits) and the K-map labels x[1], x[2], x[3], x[4]. "<em>Wait the input x is 4 bits? ... Wait the K-map labels the x as x[1] to x[4].</em>"</li>
                        <li>
                          <strong>Key Decision:</strong> Decided to align the Verilog input declaration with the K-map labels for clarity, choosing <code>input [4:1] x</code>. "<strong>Let's assume the input is a four-bit vector named x, with each bit labeled x1, x2, x3, x4, such that: <code>input [4:1] x; // x[1], x[2], x[3], x[4]</code></strong>" ... "<strong>Thus: x1 is x[1] ... x4 is x[4]</strong>"
                        </li>
                      </ul>
                    </li>
                    <li>
                      <strong>K-map Grouping and Simplification:</strong>
                      <ul>
                        <li>
                          <strong>Key Strategy:</strong> Focused on finding the minimal Sum-of-Products (SOP) expression by grouping the '1's, using 'd' (don't cares) where beneficial. "<strong>Looking for largest possible groups of adjacent cells.</strong>"
                        </li>
                        <li>Identified all cells containing '1'.</li>
                        <li>
                          <strong>Key Grouping 1:</strong> Recognized the large group covering the cells where x3=1 and x1=0 (spanning rows x3x4=11 and x3x4=10, and columns x1x2=00 and x1x2=01). Identified the corresponding terms: x3 &amp; x4 &amp; ~x1 and x3 &amp; ~x4 &amp; ~x1.
                        </li>
                        <li>
                          <em>Effective Reflection &amp; Simplification:</em> Correctly applied Boolean algebra (x4 + ~x4 = 1) to simplify these two terms into a single essential prime implicant: <strong>x3 &amp; ~x1</strong>. "<em>Wait term1 (x3 x4 ~x1) + term2 (x3 ~x4 ~x1) = x3 ~x1 (x4 + ~x4) → x3 ~x1 *1 → x3 ~x1.</em>"
                        </li>
                        <li>
                          <strong>Key Grouping 2:</strong> Identified the remaining isolated '1' cell at x3=0, x4=1, x1=1, x2=1. "<strong>Row x3x4=01 and x1x2=11: f=1.</strong>"
                        </li>
                        <li>
                          <strong>Key Term 2:</strong> Correctly determined the minterm for this isolated '1' as <strong>~x3 &amp; x4 &amp; x1 &amp; x2</strong>. "<strong>Term3: ~x3 &amp; x4 &amp; x1 &amp; x2</strong>"
                        </li>
                      </ul>
                    </li>
                    <li>
                      <strong>Formulating the Final Boolean Expression:</strong>
                      <ul>
                        <li>
                          <strong>Key Step:</strong> Combined the identified essential prime implicants using the OR operation. "<strong>F = (x3 &amp; ~x1) | (~x3 &amp; x4 &amp; x1 &amp; x2)</strong>"
                        </li>
                        <li>
                          <em>Effective Reflection:</em> Double-checked the variable correspondence in the terms (e.g., confirming ~x3 means x3=0). "<em>Wait wait, the variables in the second term are x3=0 (because ~x[3]...), x4=1 (x[4]), x1=1 (x[1]), x2=1 (x[2]). Yes. So that's correct.</em>"
                        </li>
                      </ul>
                    </li>
                    <li>
                      <strong>Translating to Verilog Code:</strong>
                      <ul>
                        <li>
                          <strong>Key Step:</strong> Mapped the derived Boolean expression directly to a Verilog <code>assign</code> statement, using the chosen <code>x[4:1]</code> indexing. "<strong><code>assign f = (x[3] &amp; ~x[1]) | (~x[3] &amp; x[4] &amp; x[1] &amp; x[2]);</code></strong>"
                        </li>
                        <li>Finalized the module structure. "<strong>Thus the final code would look like:...</strong>"</li>
                      </ul>
                    </li>
                  </ol>
                </div>
                <div class="code-block">
                  <pre class="card"><code class="language-verilog">
module TopModule (input [4:1] x, output f); // 正确且清晰的输入声明
  assign f = (x[3] & ~x[1]) | (~x[3] & x[4] & x[1] & x[2]);
endmodule
                  </code></pre>
                </div>
                <div class="content">
                  <h4 class="title is-5"></h4>
                  <p>Case 3:</p>
                </div>
                <div class="problem-description">
                  <h5 class="title is-6 has-text-weight-bold">Problem Description</h5>
                  <p style="white-space: pre-wrap;">I would like you to implement a module named TopModule with the following
interface. All input and output ports are one bit unless otherwise
specified.

- input x (4 bits)
- input y (4 bits)
- output sum (5 bits)

Implement a 4-bit adder with full adders. The output sum should include
the overflow bit.
                  </p>
                </div>
                <div class="reasoning-process">
                  <h5 class="title is-6 has-text-weight-bold">Reasoning Process</h5>
                    <ol>
                      <li>
                        <strong>Understanding Output Specification:</strong>
                        <ul>
                          <li>Analyzed the output sum (5 bits) requirement.</li>
                          <li>
                            <strong>Key Insight:</strong> Correctly deduced that the 5-bit output naturally accommodates the 4 sum bits resulting from the 4-bit addition, plus the final carry-out bit (often considered the overflow in this context).
                            <blockquote>
                              "...maximum sum is 15 + 15 = 30, which is 5 bits. So the sum here must be the 4 bits plus the carry-out as the overflow bit?"
                            </blockquote>
                            <blockquote>
                              "So sum (5 bits) would consist of the 4 sum bits and the carry out."
                            </blockquote>
                          </li>
                        </ul>
                      </li>

                      <li>
                        <strong>Considering Behavioral vs. Structural Implementation:</strong>
                        <ul>
                          <li>Identified the simple behavioral approach using the Verilog + operator: <code>assign sum = x + y;</code>.
                            <blockquote>
                              "Wait, yes. Because in Verilog, if you add two 4-bit numbers, the result is the same as if they are 32-bit (integer), so the sum is correct."
                            </blockquote>
                          </li>
                          <li>
                            <strong>Effective Reflection &amp; Key Constraint Adherence:</strong> Critically re-evaluated the prompt's specific requirement: "**Implement a 4-bit adder with full adders.**". Realized the simple behavioral approach (+ operator) does not satisfy this explicit structural constraint.
                            <blockquote>
                              "Wait this is super simple, but if the user requires a structural implementation with individual full adders... then I should model each full adder."
                            </blockquote>
                            <blockquote>
                              "But the question says: 'Implement a 4-bit adder with full adders'. So probably, we are supposed to create the adder structurally."
                            </blockquote>
                          </li>
                        </ul>
                      </li>

                      <li>
                        <strong>Designing the Ripple-Carry Structure:</strong>
                        <ul>
                          <li>
                            <strong>Key Step:</strong> Outlined the standard 4-bit ripple-carry adder structure using four <code>FullAdder</code> instances (FA0 to FA3).
                          </li>
                          <li>Defined the connections:
                            <ul>
                              <li>Initial carry-in <code>cin=0</code> for the LSB adder (FA0).</li>
                              <li>Carry-out of each stage (<code>FAi.cout</code>) connects to the carry-in of the next stage (<code>FA(i+1).cin</code>).</li>
                              <li>Inputs <code>x[i]</code> and <code>y[i]</code> connect to the <code>a</code> and <code>b</code> inputs of <code>FAi</code>.</li>
                            </ul>
                          </li>
                          <li>
                            <blockquote>
                              "...create four full adders connected together in a ripple carry fashion."
                            </blockquote>
                            <blockquote>
                              "FA0: x[0], y[0], cin=0 → s0, c1."
                            </blockquote>
                            <blockquote>
                              "FA3: x[3], y[3], cin=c2 → s3, c4 (overflow bit)." (Note: internal carry naming c0..c3 was refined later).
                            </blockquote>
                          </li>
                        </ul>
                      </li>

                      <li>
                        <strong>Mapping Component Outputs to Final sum:</strong>
                        <ul>
                          <li>
                            <strong>Key Step:</strong> Determined how the individual outputs of the Full Adders constitute the final 5-bit <code>sum[4:0]</code> output.
                          </li>
                          <li>Correctly mapped:
                            <ul>
                              <li><code>FA0.sum</code> -&gt; <code>sum[0]</code> (LSB)</li>
                              <li><code>FA1.sum</code> -&gt; <code>sum[1]</code></li>
                              <li><code>FA2.sum</code> -&gt; <code>sum[2]</code></li>
                              <li><code>FA3.sum</code> -&gt; <code>sum[3]</code></li>
                              <li><strong><code>FA3.cout</code> -&gt; <code>sum[4]</code> (MSB / Carry-out / Overflow bit)</strong></li>
                            </ul>
                          </li>
                          <li>
                            <blockquote>
                              "...sum[0] comes from FA0's sum."
                            </blockquote>
                            <blockquote>
                              "...sum[3] from FA3."
                            </blockquote>
                            <blockquote>
                              "sum[4] is the carry-out from FA3..."
                            </blockquote>
                            <blockquote>
                              "Wait sum[4] here is the cout of FA3 which is the overall carry, so that's correct."
                            </blockquote>
                          </li>
                        </ul>
                      </li>

                      <li>
                        <strong>Defining the FullAdder Sub-Module:</strong>
                        <ul>
                          <li>
                            <strong>Key Step:</strong> Recognized the necessity of providing the Verilog definition for the <code>FullAdder</code> module itself, as it's instantiated within <code>TopModule</code>.
                          </li>
                          <li>
                            <blockquote>
                              "Wait, but in Verilog, all the modules should be in the same code. Wait yes, in Verilog, you can have multiple modules in one file..."
                            </blockquote>
                            <blockquote>
                              "But to compile properly, the FullAdder must be declared..."
                            </blockquote>
                            <blockquote>
                              "So the code would have two modules: one for FullAdder and one for TopModule."
                            </blockquote>
                          </li>
                          <li>Wrote the standard combinational logic for a full adder: <code>assign sum = a ^ b ^ cin;</code> and <code>assign cout = (a &amp; b) | (a &amp; cin) | (b &amp; cin);</code>.</li>
                        </ul>
                      </li>
                    </ol>
                </div>
                <div class="code-block">
                  <pre class="card"><code class="language-verilog">
  module FullAdder (
    input a,
    input b,
    input cin,
    output sum,
    output cout
);
    assign sum = a ^ b ^ cin; 
    assign cout = (a & b) | (a & cin) | (b & cin); 
endmodule


module TopModule (
    input [3:0] x,
    input [3:0] y,
    output [4:0] sum
);
    wire c0, c1, c2; 


    FullAdder FA0 (
        .a(x[0]),
        .b(y[0]),
        .cin(1'b0), 
        .sum(sum[0]), 
        .cout(c0)  
    );

    FullAdder FA1 (
        .a(x[1]),
        .b(y[1]),
        .cin(c0),  
        .sum(sum[1]),
        .cout(c1)    
    );

    FullAdder FA2 (
        .a(x[2]),
        .b(y[2]),
        .cin(c1),  
        .sum(sum[2]),
        .cout(c2)
    );

    FullAdder FA3 (
        .a(x[3]),
        .b(y[3]),
        .cin(c2),  
        .sum(sum[3]), 
        .cout(sum[4]) 
    );
endmodule
                  </code></pre>
                </div>
                  <div class="content">
                    <h4 class="title is-5"></h4>
                    <h4 class="title is-5">RTLLM v1.1</h4>
                    <p>Case 1:</p>
                  </div>
                  <div class="problem-description">
                    <h5 class="title is-6 has-text-weight-bold">Problem Description</h5>
                    <p style="white-space: pre-wrap;">Act as a professional Verilog designer and implement a 16-bit divider module.
Functional Requirements
Inputs
A : 16-bit dividend
B : 8-bit divisor
Outputs
result : 16-bit quotient
odd : 16-bit remainder
Operation
Use pure combinational logic to perform division.
Extract the upper bits of A matching the width of B (i.e., 8 bits).
Compare these extracted bits with B:
If the extracted bits are greater than or equal to B, set the corresponding quotient bit to 1 and update the remainder as (extracted bits - B).
Otherwise, set the quotient bit to 0 and keep the remainder unchanged.
Concatenate the updated remainder with the next highest bit of A and repeat this process until all bits of A have been processed.
The final outputs are:
result: 16-bit quotient
odd: 16-bit remainder
Implementation Details
Use two always @(*) combinational blocks:
The first block captures the input values into internal registers a_reg and b_reg.
The second block performs the division operation using a loop.
Module Name
div_16bit
Deliverable
Provide the complete, synthesizable Verilog code following the above specifications.
                    </p>
                  </div>
                  <div class="reasoning-process">
                    <h5 class="title is-6 has-text-weight-bold">Reasoning Process</h5>
                    <ol>
                      <li>
                        <strong>Initial Problem Interpretation &amp; Identifying Ambiguity:</strong>
                        <ul>
                          <li>Understood the goal: 16-bit dividend / 8-bit divisor -&gt; 16-bit quotient, 16-bit remainder using combinational logic.</li>
                          <li>
                            <em>Effective Reflection:</em> Noticed the described algorithm ("Extract higher bits... Compare... Concatenate remainder with highest remaining 1-bit...") seemed potentially unclear or non-standard compared to typical hardware division algorithms. "...<em>The process description in the problem statement seems to mention that the remainder gets built up...</em>" ... "<em>Wait, but the description here is a bit unclear. Let me read again.</em>"
                          </li>
                          <li>
                            <em>Effective Reflection:</em> Questioned the 16-bit remainder output size, as typically remainder &lt; divisor (which is 8-bit). Recognized this might be a specific requirement despite being non-standard. "...<em>But the problem statement says that the remainder is 16 bits. That's a bit different, perhaps?</em>" ... "<em>But per the problem statement, the remainder is 16 bits.</em>"
                          </li>
                        </ul>
                      </li>
                      <li>
                        <strong>Choosing a Standard Implementable Algorithm:</strong>
                        <ul>
                          <li>
                            <em>Effective Reflection &amp; Key Decision:</em> Faced with the potentially confusing custom algorithm description, the model pivoted towards a <strong>standard iterative binary division algorithm</strong> (similar to restoring/non-restoring methods) as a more robust and clearly defined implementation path. It focused on the core steps: shift remainder, bring down dividend bit, compare, potentially subtract, set quotient bit. "<strong>Wait, perhaps the algorithm is similar to division steps where, for each iteration: remainder = (remainder &lt;&lt; 1) | (next_bit_from_dividend)...</strong>" ... "<strong>Let's code this standard division algorithm.</strong>"
                          </li>
                        </ul>
                      </li>
                      <li>
                        <strong>Addressing the Critical Bit-Width Mismatch:</strong>
                        <ul>
                          <li>
                            <em>Effective Reflection &amp; Key Insight:</em> Explicitly identified the core challenge of comparing/subtracting the potentially 16-bit wide remainder with the 8-bit divisor <code>b_reg</code>. "<strong>Wait, the divisor is 8 bits. If the temp_remainder is 16 bits... compare {8'd0, b_reg} with temp_remainder.</strong>"
                          </li>
                          <li>
                            <strong>Key Step:</strong> Correctly determined the solution: <strong>zero-extend the 8-bit divisor <code>b_reg</code> to 16 bits</strong> for both the comparison and the subtraction operations using concatenation: <strong><code>{8'd0, b_reg}</code></strong>. This ensures operations occur between values of the same width.
                          </li>
                        </ul>
                      </li>
                      <li>
                        <strong>Final Verification:</strong>
                        <ul>
                          <li>
                            <em>Effective Reflection:</em> Performed a mental check with an example (<code>A=0x00FF</code>, <code>B=0x0F</code>) to confirm the algorithm's expected output matched the logic. "<strong>Testing for example... Quotient should be 17... remainder zero... Thus, code would assign quotient = 16'h0011, remainder 0.</strong>"
                          </li>
                        </ul>
                      </li>
                    </ol>
                  </div>
                  <div class="code-block">
                    <pre class="card"><code class="language-verilog">
module div_16bit(
  input [15:0] A,
  input [7:0] B,
  output [15:0] result,
  output [15:0] odd
);

  reg [15:0] a_reg;
  reg [7:0] b_reg;
  reg [15:0] quotient;
  reg [15:0] remainder;
  integer i;

  
  always @* begin
      a_reg = A;
      b_reg = B;
  end

  
  always @* begin
      remainder = 16'd0;
      quotient = 16'd0;
      for (i = 15;
i >= 0;
i = i - 1) begin
          remainder = (remainder << 1) | a_reg[i];
          if (remainder >= {8'd0, b_reg}) begin
              remainder = remainder - {8'd0, b_reg};
              quotient[i] = 1;
          end else begin
              quotient[i] = 0;
          end
      end
  end

  assign result = quotient;
  assign odd = remainder;

endmodule
                    </code></pre>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  <!--/ Three-Column Showcase Section with Hover Effect -->
  </section>

  <section class="section">
    <div class="container is-max-desktop">
      <div class="columns is-centered">
        <div class="column">
          <div class="content">
            <h2 class="title is-3"> Multi-level Code Summarization</h2>
            <p>
              Manual annotation is prohibitively time-consuming and costly. Hence, we employed GPT-3.5 to generate high-level summaries for each Verilog module as its requirement description. As analyzed in VerilogEval, when required for summarising, LLMs often produce verbose descriptions, preferring line-by-line explanations over high-level summaries. To address this issue, we introduce a multi-level summarization method, employing few-shot learning to guide GPT-3.5 in first producing detailed descriptions and then abstracting high-level summaries.
            </p>
            <p>
              An actual example of the prompt for multi-level summarization. (a) The prompt provided to GPT-3.5. (b) An example of the demonstrations, with code, low-level descriptions, and high-level summaries. (c) Summaries responded from GPT-3.5 with and (d) without multi-level summarization.
            </p>
            <img src="./static/images/multilevel_sum_demo.png">
          </div>
        </div>
      </div>

      <div class="columns is-centered">
        <div class="column">
            <div class="content">
                <h2 class="title is-3">Chat-FIM-Tag supervised fine-tuning</h2>
                <p>
                    To enhance the FIM capability of the model, we conduct infilling fine-tuning. Specifically, we randomly partition each training document into prefix, middle, and suffix sections, then concatenate them using special FIM tokens. We have processed the training document into the following tokenized version:
                </p>
                <p style="text-align: center;">
                  <code>
                      &lt;PRE&gt;&#123;prefix&#125;&lt;SUF&gt;&#123;suffix&#125;&lt;MID&gt;&#123;middle&#125;&lt;EOT&gt;&lt;/EOT&gt;
                  </code>
                </p>
                <p>
                    where <code>&lt;PRE&gt;</code>, <code>&lt;MID&gt;</code>, <code>&lt;SUF&gt;</code>, and <code>&lt;EOT&gt;</code> need to be modified according to the model's tokenization. It is noteworthy that we preserve the loss for all the prefix, middle, and suffix sections in this study.
                </p>
                <p>
                    When the data for a single language is limited, including multiple languages can affect the performance of that language. To address this challenge, we have empirically found that emphasizing the distinctions between languages during training helps improve the performance of each language. Specifically, we incorporate language-specific tags, that is <code>&lt;Verilog&gt;</code> and <code>&lt;Chisel&gt;</code>, during training.
                </p>
            </div>
        </div>
      </div>
      <div class="columns is-centered">
        <div class="column">
          <div class="content">
            <h2 class="title is-3">Results on VerilogEval and RTLLM</h2>
            <p>
              In this section, we compare our method with previous work fairly on VerilogEval and RTLLM.
              Table <a href="#tab:main_exp">Table 1</a> compares the main results of our <strong>CodeV</strong> with baseline methods on the VerilogEval and RTLLM benchmarks. 
              We evaluate CodeLlama, DeepSeek-Coder, CodeQwen, and Qwen2.5-Coder, while other baseline results are sourced from RTLCoder, BetterV, AutoVCoder, OriGen, CraftRTL, and HAVEN. The results show that:
            </p>
            <p>
              <strong>CodeV-Verilog performs well and achieves state-of-the-art on Verilog-Machine.</strong> 
              CodeV-Verilog performed well in the VerilogEval and RTLLM benchmarks, surpassing the RTLCoder and BetterV methods in the VerilogEval benchmark test,
              particularly in the most challenging pass@1 metric where CodeV-Verilog-QC achieves 80.1% in VerilogEval-machine, and CodeV-Verilog-QC achieves 59.2% in VerilogEval-human, significantly outperforming both GPT-4 and BetterV-CodeQwen. In the RTLLM v1.1 benchmark, CodeV-Verilog-CL nearly matches GPT-4's functional check success rate, failing in just 1 more case out of 29 circuits compared to GPT-4, and significantly outperforms all other models. Also, CodeV-Verilog significantly outperforms its GPT-3.5-turbo-0125 summarization model. These results demonstrate that, contributed by a high-quality instruction tuning dataset, CodeV-Verilog exhibits significant superiority in Verilog generation tasks.
            </p>
            <p>
              <strong>The performance of different base models becomes closer after fine-tuning.</strong>
              This is reasonable because the base models are trained on different training data but use the same fine-tuning data, which reduces their differences. Additionally, we find that after fine-tuning, CodeQwen surpasses DeepSeek-Coder, and CodeLlama also outperformed the other two models on VerilogEval-Machine pass@1 after fine-tuning. This indicates that the performance of a base model in specific domains does not necessarily align with its performance after fine-tuning.
            </p>
            <figure>
              <img src="./static/images/result20250413.png" alt="Comparison Results">
              <figcaption>Table 1: Comparison of our CodeV models against various baseline models. Accuracy data are cited from their original papers. * are the result updated by us with the new version.</figcaption>
            </figure>
          </div>
        </div>
      </div>

      <div class="columns is-centered">
        <div class="column">
          <div class="content">
            <h2 class="title is-3">Results on Multi-lingual and Multi-Scenario Tasks</h2>
            <p>
              We evaluate LLMs' capabilities for multi-lingual and multi-scenario tasks in this section.
              As mentioned before, we added 18.7K Chisel data extension based on the existing 165K Verilog dataset, thereby constructing a more comprehensive training corpus, 184K-Verilog-Chisel. 
              Then, we utilize the Chat-FIM-Tag supervised fine-tuning process to develop the CodeV-All series, which can handle tasks in different languages (Verilog and Chisel) and scenarios (Chat and FIM).
              
              To evaluate the models' multi-lingual (Verilog and Chisel) generation capabilities on Chat tasks, we evaluate both our CodeV-All and baseline LLMs across four benchmarks: VerilogEval, RTLLM, ChiselTutorial, and ChiselEval. The results are presented in Tables 1 and 2. To evaluate the models' multi-scenario ability, we evaluate CodeV-All on the proposed FIM benchmarks. The results are shown in Tables 3, 4, and 5.
               <!-- We can conclude that: -->
              
              <!-- <ul>
                  <li><strong>The inclusion of the Chisel dataset leads to an improvement in Chisel performance.</strong></li>
              
                  <li><strong>CodeV-All demonstrates strong performance on Chisel generation tasks.</strong></li>
              
                  <li><strong>CodeV-All performs comparable to CodeV-Verilog on Verilog tasks.</strong></li>
              
                  <li><strong>Our fine-tuning method is effective in improving the model's infilling performance.</strong></li>
              </ul> -->
            </p>
            <div class="columns is-centered">
              <!-- Visual Effects. -->
              <div class="column" style="max-width: 100%; width: 100%;">
                <div class="content">
                  <h2 class="title is-3"></h2>
                  <p></p>
                  <figure>
                    <img src="./static/images/chisel_benchmark.png" style="width: 100%;" alt="ChiselEval and ChiselTutorial Performance">
                    <figcaption>Table 2: Performance of models on ChiselEval and ChiselTutorial.</figcaption>
                  </figure>
                </div>
              </div>
              <!--/ Visual Effects. -->
              <!-- Matting. -->
              <div class="column"  style="max-width: 100%; width: 100%;">
                <div class="content">
                  <h2 class="title is-3"></h2>
                  <p></p>
                  <figure>
                      <img src="./static/images/rtllm-fim-benchmark.png" alt="ChiselEval-FIM Comparison">
                      <figcaption>Table 3: Comparison between our CodeV models and the base models on VerilogEval-FIM.</figcaption>
                  </figure>
                </div>
              </div>
              <!--/ Matting. -->
            </div>
            <figure>
              <img src="./static/images/FIM-chisel-benchmark.png" style="width: 70%;" >
              <figcaption>Table 4: Comparison between our CodeV-All models and the base models on ChiselEval-FIM.</figcaption>
            </figure>
            <figure>
              <img src="./static/images/verilog-fim-benchmark.png" >
              <figcaption>Table 5: Comparison between our CodeV-All models and the base models on VerilogEval-FIM.</figcaption>
            </figure>
            
        </div>

          </div>
        </div>
      </div>
      
    <!-- <hr/> -->
    <!-- <section class="section" id="BibTeX"> -->
      <!-- <div class="columns is-centered"> -->
        <div class="container content is-max-desktop">
            <h2 class="title is-3"> BibTex </h2>
              <pre>

  <code class="nohighlight" style="background-color: transparent; color: black; font-family: monospace;">@misc{zhao2024codevempoweringllmsverilog,
    title={CodeV: Empowering LLMs for Verilog Generation through Multi-Level Summarization},
    author={Yang Zhao and Di Huang and Chongxiao Li and Pengwei Jin and Ziyuan Nan and Tianyun Ma and Lei Qi and Yansong Pan and Zhenxing Zhang and Rui Zhang and Xishan Zhang and Zidong Du and Qi Guo and Xing Hu and Yunji Chen},
    year={2024},
    eprint={2407.10424},
    archivePrefix={arXiv},
    primaryClass={cs.PL},
    url={https://arxiv.org/abs/2407.10424},
  }</code>
              </pre>
      </div>
      <!-- </section> -->
  </section>

  <!-- <hr/> -->
  

  <footer class="footer">
    <div class="container">
      <div class="columns is-centered">
        <div class="column is-8">
          <div class="content">
            <p>
              This website is licensed under a <a rel="license"
                href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
                Commons Attribution-ShareAlike 4.0 International License</a>.
            </p>
            <p>
              Thanks for the website template <a href="https://nerfies.github.io">Nerfies</a>
            </p>
          </div>
        </div>
      </div>
    </div>
  </footer>
</body>

</html>